<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Piano Keys Chord Transposition Wizard</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --cream: #faf8f3; --charcoal: #2a2a2a; --accent: #c8553d;
            --accent-light: #e8855f; --sage: #8b9d83; --border: #d4c5b9;
            --white-key-width: 45px; --white-key-spacing: 47px; --black-key-offset: 30px;
        }
        body {
            font-family: 'DM Sans', sans-serif; background: var(--cream);
            color: var(--charcoal); min-height: 100vh; padding: 2rem 1rem;
            background-image: radial-gradient(circle at 20% 80%, rgba(200,85,61,0.03) 0%, transparent 50%),
                              radial-gradient(circle at 80% 20%, rgba(139,157,131,0.04) 0%, transparent 50%);
        }
        .container { max-width: 1100px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 3rem; }
        h1 { font-family: 'Crimson Pro', serif; font-size: 3.5rem; font-weight: 700; color: var(--charcoal); margin-bottom: 0.5rem; letter-spacing: -0.02em; }
        .subtitle { font-size: 1.1rem; color: #6b6b6b; font-weight: 400; }
        .section { background: white; border-radius: 16px; padding: 2.5rem; margin-bottom: 2rem; box-shadow: 0 2px 12px rgba(0,0,0,0.04); border: 1px solid var(--border); }
        .section-title { font-family: 'Crimson Pro', serif; font-size: 1.5rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--charcoal); }
        .key-selector { display: flex; gap: 1.5rem; align-items: center; justify-content: center; margin-bottom: 2rem; flex-wrap: wrap; }
        .transpose-group { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
        .transpose-group label { font-weight: 500; font-size: 0.9rem; color: #666; text-align: center; }
        select { padding: 0.75rem 1.25rem; font-size: 1.1rem; font-family: 'DM Sans', sans-serif; font-weight: 500; border: 2px solid var(--border); border-radius: 8px; background: white; color: var(--charcoal); cursor: pointer; transition: all 0.2s; min-width: 150px; }
        select:hover { border-color: var(--accent); }
        select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(200,85,61,0.1); }
        .piano { position: relative; display: flex; height: 200px; background: var(--charcoal); padding: 1rem; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); justify-content: center; overflow-x: auto; }
        .octave { display: flex; position: relative; }
        .key { position: relative; cursor: pointer; transition: all 0.15s; user-select: none; }
        .white-key { width: var(--white-key-width); height: 160px; background: white; border: 2px solid #ddd; border-radius: 0 0 6px 6px; margin: 0 1px; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 1rem; font-size: 0.85rem; color: #999; font-weight: 500; }
        .white-key:hover { background: #f8f8f8; transform: translateY(2px); }
        .white-key.active { background: var(--accent-light); color: white; border-color: var(--accent); }
        .black-key { width: 30px; height: 100px; background: var(--charcoal); border: 2px solid #1a1a1a; border-radius: 0 0 4px 4px; position: absolute; z-index: 2; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.2rem; padding: 0.5rem 0.2rem; font-size: 0.65rem; color: white; font-weight: 500; text-align: center; }
        .black-key:hover { background: #1a1a1a; transform: translateY(2px); }
        .black-key.active { background: var(--accent); border-color: var(--accent-light); color: white; }
        .black-key[data-position="0"]  { left: calc(var(--white-key-spacing) * 0  + var(--black-key-offset)); }
        .black-key[data-position="1"]  { left: calc(var(--white-key-spacing) * 1  + var(--black-key-offset)); }
        .black-key[data-position="3"]  { left: calc(var(--white-key-spacing) * 3  + var(--black-key-offset)); }
        .black-key[data-position="4"]  { left: calc(var(--white-key-spacing) * 4  + var(--black-key-offset)); }
        .black-key[data-position="5"]  { left: calc(var(--white-key-spacing) * 5  + var(--black-key-offset)); }
        .black-key[data-position="7"]  { left: calc(var(--white-key-spacing) * 7  + var(--black-key-offset)); }
        .black-key[data-position="8"]  { left: calc(var(--white-key-spacing) * 8  + var(--black-key-offset)); }
        .black-key[data-position="10"] { left: calc(var(--white-key-spacing) * 10 + var(--black-key-offset)); }
        .black-key[data-position="11"] { left: calc(var(--white-key-spacing) * 11 + var(--black-key-offset)); }
        .black-key[data-position="12"] { left: calc(var(--white-key-spacing) * 12 + var(--black-key-offset)); }
        .black-key[data-position="14"] { left: calc(var(--white-key-spacing) * 14 + var(--black-key-offset)); }
        .black-key[data-position="15"] { left: calc(var(--white-key-spacing) * 15 + var(--black-key-offset)); }
        .black-key[data-position="17"] { left: calc(var(--white-key-spacing) * 17 + var(--black-key-offset)); }
        .chord-info { text-align: center; margin-top: 1.5rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(200,85,61,0.05), rgba(139,157,131,0.05)); border-radius: 12px; border: 1px solid var(--border); }
        .chord-name { font-family: 'Crimson Pro', serif; font-size: 2rem; font-weight: 700; color: var(--accent); margin-bottom: 0.5rem; }
        .instruction { text-align: center; color: #999; font-size: 0.95rem; margin-top: 1rem; font-style: italic; }
        .reset-btn { padding: 0.75rem 2rem; background: var(--sage); color: white; border: none; border-radius: 8px; font-family: 'DM Sans', sans-serif; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.2s; }
        .reset-btn:hover { background: #7a8b74; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(139,157,131,0.3); }
        .play-btn { display: block; margin: 1rem auto 0; padding: 0.75rem 2rem; background: var(--accent); color: white; border: none; border-radius: 8px; font-family: 'DM Sans', sans-serif; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.2s; }
        .play-btn:hover { background: var(--accent-light); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(200,85,61,0.3); }
        .button-group { display: flex; gap: 1rem; justify-content: center; margin-top: 1.5rem; flex-wrap: wrap; }
        .go-btn { padding: 0.75rem 2rem; background: var(--accent); color: white; border: none; border-radius: 8px; font-family: 'DM Sans', sans-serif; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.2s; }
        .go-btn:hover { background: var(--accent-light); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(200,85,61,0.3); }
        .go-btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        @media (max-width: 768px) {
            :root { --white-key-width: 32px; --white-key-spacing: 34px; --black-key-offset: 21px; }
            h1 { font-size: 2rem; }
            .section { padding: 1.5rem; }
            .black-key { width: 22px; }
            .key-selector { gap: 1rem; }
            .piano { justify-content: flex-start; }
        }
        footer { text-align: center; margin-top: 4rem; padding: 2rem 1rem; color: #666; font-size: 0.9rem; border-top: 1px solid var(--border); }
        footer a { color: var(--accent); text-decoration: none; font-weight: 600; transition: color 0.2s; }
        footer a:hover { color: var(--accent-light); text-decoration: underline; }
        .copyright { margin-bottom: 0.5rem; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef } = React;

        let audioContext = null;
        function initAudio() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        function playNote(note, octave) {
            initAudio();
            const freqs = {
                'C':261.63,'B#':261.63,'C#':277.18,'Db':277.18,'D':293.66,
                'D#':311.13,'Eb':311.13,'E':329.63,'Fb':329.63,'F':349.23,
                'E#':349.23,'F#':369.99,'Gb':369.99,'G':392.00,'G#':415.30,
                'Ab':415.30,'A':440.00,'A#':466.16,'Bb':466.16,'B':493.88,'Cb':493.88
            };
            const base = freqs[note];
            if (!base) return;
            const freq = base * Math.pow(2, octave - 4);
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain); gain.connect(audioContext.destination);
            osc.frequency.value = freq; osc.type = 'triangle';
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);
            osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime + 1.5);
        }
        function playChord(notes) {
            initAudio();
            notes.forEach(n => playNote(n.replace(/[0-9]/g,''), parseInt(n.match(/[0-9]/g)[0])));
        }

        const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

        // â”€â”€ CHANGE 1: expanded dropdown list including flat names â”€â”€
        const DROPDOWN_NOTES = [
            { value: 'C',  label: 'C'        },
            { value: 'C#', label: 'Câ™¯'       },
            { value: 'Db', label: 'Dâ™­'       },
            { value: 'D',  label: 'D'        },
            { value: 'D#', label: 'Dâ™¯'       },
            { value: 'Eb', label: 'Eâ™­'       },
            { value: 'E',  label: 'E'        },
            { value: 'F',  label: 'F'        },
            { value: 'F#', label: 'Fâ™¯'       },
            { value: 'Gb', label: 'Gâ™­'       },
            { value: 'G',  label: 'G'        },
            { value: 'G#', label: 'Gâ™¯'       },
            { value: 'Ab', label: 'Aâ™­'       },
            { value: 'A',  label: 'A'        },
            { value: 'A#', label: 'Aâ™¯'       },
            { value: 'Bb', label: 'Bâ™­'       },
            { value: 'B',  label: 'B'        },
        ];

        function getChromaticIndex(note) {
            const m = {
                'C':0,'B#':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,
                'E':4,'Fb':4,'F':5,'E#':5,'F#':6,'Gb':6,'G':7,
                'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11,'Cb':11
            };
            return m[note] !== undefined ? m[note] : NOTES.indexOf(note);
        }

        const WHITE_KEYS = [
            {note:'C',octave:4},{note:'D',octave:4},{note:'E',octave:4},{note:'F',octave:4},
            {note:'G',octave:4},{note:'A',octave:4},{note:'B',octave:4},
            {note:'C',octave:5},{note:'D',octave:5},{note:'E',octave:5},{note:'F',octave:5},
            {note:'G',octave:5},{note:'A',octave:5},{note:'B',octave:5},
            {note:'C',octave:6},{note:'D',octave:6},{note:'E',octave:6},{note:'F',octave:6},{note:'G',octave:6}
        ];
        const BLACK_KEYS = [
            {note:'C#',sharp:'C#',flat:'Db',octave:4,position:0},
            {note:'D#',sharp:'D#',flat:'Eb',octave:4,position:1},
            {note:'F#',sharp:'F#',flat:'Gb',octave:4,position:3},
            {note:'G#',sharp:'G#',flat:'Ab',octave:4,position:4},
            {note:'A#',sharp:'A#',flat:'Bb',octave:4,position:5},
            {note:'C#',sharp:'C#',flat:'Db',octave:5,position:7},
            {note:'D#',sharp:'D#',flat:'Eb',octave:5,position:8},
            {note:'F#',sharp:'F#',flat:'Gb',octave:5,position:10},
            {note:'G#',sharp:'G#',flat:'Ab',octave:5,position:11},
            {note:'A#',sharp:'A#',flat:'Bb',octave:5,position:12},
            {note:'C#',sharp:'C#',flat:'Db',octave:6,position:14},
            {note:'D#',sharp:'D#',flat:'Eb',octave:6,position:15},
            {note:'F#',sharp:'F#',flat:'Gb',octave:6,position:17}
        ];

        function correctChordSpelling(notes, chordType, chordRoot) {
            if (notes.length < 2 || !chordRoot) return notes;
            const noteNames = ['C','D','E','F','G','A','B'];
            const rootBase = chordRoot.replace(/[#b]/g,'');
            const rootIndex = noteNames.indexOf(rootBase);
            const rootChromatic = getChromaticIndex(chordRoot);
            const rootNoteInChord = notes.find(n => getChromaticIndex(n.replace(/[0-9]/g,'')) === rootChromatic);
            if (!rootNoteInChord) return notes;

            const buildSpelling = (intervals, scaleSteps) => {
                return intervals.map((interval, idx) => {
                    const scaleDegree = (rootIndex + scaleSteps[idx]) % 7;
                    let noteName = noteNames[scaleDegree];
                    const targetChromatic = (rootChromatic + interval) % 12;
                    const naturalChromatic = NOTES.indexOf(noteName);
                    if (naturalChromatic !== targetChromatic) {
                        const diff = (targetChromatic - naturalChromatic + 12) % 12;
                        if (diff === 1) noteName += '#';
                        else if (diff === 11) noteName += 'b';
                    }
                    return noteName;
                });
            };
            const applySpelling = (intervals, spelling) => notes.map(noteStr => {
                const note = noteStr.replace(/[0-9]/g,'');
                const octave = noteStr.match(/[0-9]/g)[0];
                const chromatic = getChromaticIndex(note);
                const intervalFromRoot = (chromatic - rootChromatic + 12) % 12;
                const toneIndex = intervals.indexOf(intervalFromRoot);
                return toneIndex >= 0 ? `${spelling[toneIndex]}${octave}` : noteStr;
            });

            // â”€â”€ Specific types first (before catch-alls like includes('aug'/'min')) â”€â”€

            // 6th chords: 6th is the 6th letter (step 5), NOT the 7th (step 6)
            if (chordType === '6') {
                return applySpelling([0,4,7,9], buildSpelling([0,4,7,9],[0,2,4,5]));
            }
            if (chordType === 'min6') {
                return applySpelling([0,3,7,9], buildSpelling([0,3,7,9],[0,2,4,5]));
            }

            // 7th chords â€” 7th is always step 6 (7th letter after root)
            if (chordType === 'maj7') {
                return applySpelling([0,4,7,11], buildSpelling([0,4,7,11],[0,2,4,6]));
            }
            if (chordType === 'min7') {
                return applySpelling([0,3,7,10], buildSpelling([0,3,7,10],[0,2,4,6]));
            }
            if (chordType === '7') {
                return applySpelling([0,4,7,10], buildSpelling([0,4,7,10],[0,2,4,6]));
            }
            if (chordType === 'min7b5') {
                return applySpelling([0,3,6,10], buildSpelling([0,3,6,10],[0,2,4,6]));
            }
            if (chordType === 'minMaj7') {
                return applySpelling([0,3,7,11], buildSpelling([0,3,7,11],[0,2,4,6]));
            }
            // aug7 / 7#5: root, M3, #5, m7
            if (chordType === 'aug7' || chordType === '7#5') {
                return applySpelling([0,4,8,10], buildSpelling([0,4,8,10],[0,2,4,6]));
            }
            // augMaj7: root, M3, #5, M7
            if (chordType === 'augMaj7') {
                return applySpelling([0,4,8,11], buildSpelling([0,4,8,11],[0,2,4,6]));
            }
            // 7b5: root, M3, b5, m7
            if (chordType === '7b5') {
                return applySpelling([0,4,6,10], buildSpelling([0,4,6,10],[0,2,4,6]));
            }

            // â”€â”€ Triads â”€â”€
            if (chordType === 'major' || chordType === '') {
                return applySpelling([0,4,7], buildSpelling([0,4,7],[0,2,4]));
            }
            if (chordType === 'minor') {
                return applySpelling([0,3,7], buildSpelling([0,3,7],[0,2,4]));
            }
            if (chordType === 'aug') {
                return applySpelling([0,4,8], buildSpelling([0,4,8],[0,2,4]));
            }
            if (chordType === 'dim') {
                return applySpelling([0,3,6], buildSpelling([0,3,6],[0,2,4]));
            }
            if (chordType === 'dim7') {
                return applySpelling([0,3,6,9], buildSpelling([0,3,6,9],[0,2,4,6]));
            }

            // â”€â”€ Sus / add chords â”€â”€
            // sus2: root, 2nd, 5th  (step 1 = 2nd letter)
            if (chordType === 'sus2') {
                return applySpelling([0,2,7], buildSpelling([0,2,7],[0,1,4]));
            }
            // sus4: root, 4th, 5th  (step 3 = 4th letter)
            if (chordType === 'sus4') {
                return applySpelling([0,5,7], buildSpelling([0,5,7],[0,3,4]));
            }
            // 7sus4: root, 4th, 5th, m7
            if (chordType === '7sus4') {
                return applySpelling([0,5,7,10], buildSpelling([0,5,7,10],[0,3,4,6]));
            }
            // 9sus4: root, 2nd, 4th, 5th, m7
            if (chordType === '9sus4') {
                return applySpelling([0,2,5,7,10], buildSpelling([0,2,5,7,10],[0,1,3,4,6]));
            }
            // add9: root, 2nd, M3, 5th
            if (chordType === 'add9') {
                return applySpelling([0,2,4,7], buildSpelling([0,2,4,7],[0,1,2,4]));
            }
            // minadd9: root, 2nd, m3, 5th
            if (chordType === 'minadd9') {
                return applySpelling([0,2,3,7], buildSpelling([0,2,3,7],[0,1,2,4]));
            }
            // add11: root, M3, 4th, 5th
            if (chordType === 'add11') {
                return applySpelling([0,4,5,7], buildSpelling([0,4,5,7],[0,2,3,4]));
            }

            // â”€â”€ Catch-all for any remaining maj/min variants not explicitly handled â”€â”€
            if (chordType && chordType.includes('maj')) {
                return applySpelling([0,4,7], buildSpelling([0,4,7],[0,2,4]));
            }
            if (chordType && chordType.includes('min')) {
                return applySpelling([0,3,7], buildSpelling([0,3,7],[0,2,4]));
            }
            if (chordType && chordType.includes('aug')) {
                return applySpelling([0,4,8], buildSpelling([0,4,8],[0,2,4]));
            }
            if (chordType && chordType.includes('dim')) {
                return applySpelling([0,3,6], buildSpelling([0,3,6],[0,2,4]));
            }
            return notes;
        }

        function getInversion(notes, rootNote) {
            if (!notes.length) return null;
            let lowestNote = notes[0], lowestValue = Infinity;
            notes.forEach(n => {
                const note = n.replace(/[0-9]/g,'');
                const octave = parseInt(n.match(/[0-9]/g)[0]);
                const v = octave * 12 + getChromaticIndex(note);
                if (v < lowestValue) { lowestValue = v; lowestNote = n; }
            });
            const bassNote = lowestNote.replace(/[0-9]/g,'');
            if (getChromaticIndex(bassNote) === getChromaticIndex(rootNote)) return null;
            const rootChromatic = getChromaticIndex(rootNote);
            const bassInterval = (getChromaticIndex(bassNote) - rootChromatic + 12) % 12;
            const invMap = {3:'1st inversion',4:'1st inversion',5:'2nd inversion',6:'2nd inversion',7:'2nd inversion',8:'2nd inversion',9:'3rd inversion',10:'3rd inversion',11:'3rd inversion',2:'4th inversion'};
            return invMap[bassInterval] || 'inversion';
        }

        function identifyChord(notes) {
            if (!notes.length) return null;
            const uniqueNotes = [...new Set(notes.map(n => n.replace(/[0-9]/g,'')))];
            if (uniqueNotes.length < 2) return null;

            const patterns = {
                'maj13(#11)':[0,2,4,6,7,9,11],'maj13':[0,2,4,7,9,11],'min13':[0,2,3,7,9,10],
                '13':[0,2,4,7,9,10],'7b13':[0,4,7,8,10],'min7b13':[0,3,7,8,10],
                'maj11(#11)':[0,2,4,6,7,11],'maj11':[0,2,4,5,7,11],'min11':[0,2,3,5,7,10],
                '11':[0,2,4,5,7,10],'maj7#11':[0,4,6,7,11],'7#11':[0,4,6,7,10],
                '9sus4':[0,2,5,7,10],'maj9':[0,2,4,7,11],'min9':[0,2,3,7,10],'9':[0,2,4,7,10],
                '7b9':[0,1,4,7,10],'7#9':[0,3,4,7,10],'min7b9':[0,1,3,7,10],'maj7#9':[0,3,4,7,11],
                '7alt':[0,1,3,4,6,10],'7b5b9':[0,1,4,6,10],'7b5#9':[0,3,4,6,10],
                '7#5b9':[0,1,4,8,10],'7#5#9':[0,3,4,8,10],'7b5':[0,4,6,10],'7#5':[0,4,8,10],
                'maj7':[0,4,7,11],'min7':[0,3,7,10],'7':[0,4,7,10],'min7b5':[0,3,6,10],
                'dim7':[0,3,6,9],'minMaj7':[0,3,7,11],'aug7':[0,4,8,10],'augMaj7':[0,4,8,11],
                '7sus4':[0,5,7,10],'6':[0,4,7,9],'min6':[0,3,7,9],'add9':[0,2,4,7],
                'minadd9':[0,2,3,7],'add11':[0,4,5,7],'sus4':[0,5,7],'sus2':[0,2,7],
                'aug':[0,4,8],'dim':[0,3,6],'minor':[0,3,7],'major':[0,4,7],'5':[0,7]
            };

            const enharmonicMap = {
                'C#':'Db','Db':'C#','D#':'Eb','Eb':'D#','F#':'Gb','Gb':'F#',
                'G#':'Ab','Ab':'G#','A#':'Bb','Bb':'A#','B':'Cb','Cb':'B',
                'E':'Fb','Fb':'E','F':'E#','E#':'F','C':'B#','B#':'C'
            };

            // If every note in the chord is a natural (no sharps or flats),
            // don't try enharmonic spellings â€” e.g., C-E-G should never suggest Fb or B#
            const allNatural = uniqueNotes.every(n => !n.includes('#') && !n.includes('b'));

            let allMatches = [];
            const rootsToTry = allNatural
                ? uniqueNotes
                : [...uniqueNotes, ...uniqueNotes.map(n => enharmonicMap[n]).filter(Boolean)];

            for (let rootNote of rootsToTry) {
                const rootIndex = getChromaticIndex(rootNote);
                const intervals = uniqueNotes.map(n => {
                    let i = getChromaticIndex(n) - rootIndex;
                    if (i < 0) i += 12;
                    return i;
                }).sort((a,b) => a-b);

                for (let [type, pattern] of Object.entries(patterns)) {
                    if (pattern.length === intervals.length) {
                        const match = [...pattern].sort((a,b)=>a-b).every((p,i) => p === intervals[i]);
                        if (match) allMatches.push({ root: rootNote, type, quality: pattern.length * 100, complete: true });
                    }
                }

                // Incomplete chord hints (only if no exact match for this root)
                if (!allMatches.some(m => m.root === rootNote && m.complete)) {
                    if (intervals.length === 3 && intervals[0]===0) {
                        const [,a,b] = intervals;
                        if (a===3&&b===10) { allMatches.push({root:rootNote,type:'min7',quality:140,complete:false}); allMatches.push({root:rootNote,type:'min7b5',quality:140,complete:false}); }
                        else if (a===4&&b===10) allMatches.push({root:rootNote,type:'7',quality:140,complete:false});
                        else if (a===4&&b===11) allMatches.push({root:rootNote,type:'maj7',quality:140,complete:false});
                        else if (a===3&&b===11) allMatches.push({root:rootNote,type:'minMaj7',quality:140,complete:false});
                        else if (a===5&&b===10) allMatches.push({root:rootNote,type:'7sus4',quality:130,complete:false});
                        else if (a===7&&b===10) { allMatches.push({root:rootNote,type:'min7',quality:130,complete:false}); allMatches.push({root:rootNote,type:'7',quality:130,complete:false}); }
                        else if (a===7&&b===11) allMatches.push({root:rootNote,type:'maj7',quality:130,complete:false});
                        else if (a===7&&b===9) { allMatches.push({root:rootNote,type:'6',quality:150,complete:false}); allMatches.push({root:rootNote,type:'min6',quality:150,complete:false}); }
                    }
                }
            }

            // Deduplicate enharmonic equivalents (e.g. D#minor vs Ebminor).
            // Decision is based solely on whether the ROOT is a natural or accidental:
            // - If one root is natural and the other is accidental, keep the natural one.
            // - If BOTH roots are accidentals (e.g. A# vs Bb), keep BOTH â€” the user
            //   should see both spellings regardless of whether other chord tones are natural.
            const deduped = [];
            for (const m of allMatches) {
                const clash = deduped.find(x =>
                    x.type === m.type &&
                    getChromaticIndex(x.root) === getChromaticIndex(m.root)
                );
                if (!clash) {
                    deduped.push(m);
                } else {
                    const mRootNatural     = !m.root.includes('#') && !m.root.includes('b');
                    const clashRootNatural = !clash.root.includes('#') && !clash.root.includes('b');
                    if (mRootNatural && !clashRootNatural) {
                        // Replace accidental-root entry with natural-root entry
                        deduped.splice(deduped.indexOf(clash), 1, m);
                    } else if (!mRootNatural && !clashRootNatural) {
                        // Both roots are accidentals â€” keep both spellings
                        deduped.push(m);
                    }
                    // else: clash already has a natural root â€” discard m
                }
            }

            const seen = new Set();
            return deduped.filter(m => {
                const k = `${m.root}${m.type}${m.complete}`;
                if (seen.has(k)) return false; seen.add(k); return true;
            }).sort((a,b) => {
                if (a.complete && !b.complete) return -1;
                if (!a.complete && b.complete) return 1;
                return b.quality - a.quality;
            }).slice(0, 5);
        }

        function ChordTransposer() {
            const [selectedNotes, setSelectedNotes] = useState([]);
            const [toRoot, setToRoot] = useState('');
            const [showTransposed, setShowTransposed] = useState(false);
            const transposedRef = useRef(null);

            const toggleNote = (note, octave) => {
                const ns = `${note}${octave}`;
                if (selectedNotes.includes(ns)) {
                    setSelectedNotes(selectedNotes.filter(n => n !== ns));
                } else {
                    setSelectedNotes([...selectedNotes, ns]);
                    playNote(note, octave);
                }
                setShowTransposed(false);
            };

            const handleGo = () => {
                if (toRoot && selectedNotes.length > 0) {
                    setShowTransposed(true);
                    setTimeout(() => transposedRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                }
            };

            const originalMatches = identifyChord(selectedNotes);
            const originalChord = originalMatches?.[0] ?? null;
            const fromRoot = originalChord?.root ?? 'C';

            // â”€â”€ CHANGE 2: use getChromaticIndex for both fromRoot and toRoot â”€â”€
            const rawTransposed = selectedNotes.map(ns => {
                const note = ns.replace(/[0-9]/g,'');
                const octave = parseInt(ns.match(/[0-9]/g)[0]);
                const noteValue = octave * 12 + NOTES.indexOf(note);
                const interval = getChromaticIndex(toRoot) - getChromaticIndex(fromRoot);
                let newValue = noteValue + interval;
                const newOctave = Math.floor(newValue / 12);
                let newIdx = newValue % 12;
                if (newIdx < 0) newIdx += 12;
                return `${NOTES[newIdx]}${newOctave}`;
            });

            const MIN_NOTE = 48, MAX_NOTE = 79;
            let adjusted = [...rawTransposed];
            let limit = 0;
            while (limit++ < 10) {
                const vals = adjusted.map(ns => { const n=ns.replace(/[0-9]/g,''); const o=parseInt(ns.match(/[0-9]/g)[0]); return o*12+NOTES.indexOf(n); });
                if (Math.min(...vals) < MIN_NOTE) adjusted = adjusted.map(ns => { const n=ns.replace(/[0-9]/g,''); const o=parseInt(ns.match(/[0-9]/g)[0]); return `${n}${o+1}`; });
                else if (Math.max(...vals) > MAX_NOTE) adjusted = adjusted.map(ns => { const n=ns.replace(/[0-9]/g,''); const o=parseInt(ns.match(/[0-9]/g)[0]); return `${n}${o-1}`; });
                else break;
            }

            const transposedMatches = identifyChord(adjusted);
            // Force any match whose root is chromatically equal to toRoot to use
            // exactly the spelling the user chose (e.g. Bb rather than A#).
            if (toRoot && transposedMatches) {
                transposedMatches.forEach(m => {
                    if (getChromaticIndex(m.root) === getChromaticIndex(toRoot)) {
                        m.root = toRoot;
                    }
                });
                // After renaming, two entries may now share the same root+type (e.g.
                // both A#dim and Bbdim become F#dim). Deduplicate by keeping the first.
                const seenKey = new Set();
                for (let i = transposedMatches.length - 1; i >= 0; i--) {
                    const k = `${transposedMatches[i].root}${transposedMatches[i].type}`;
                    if (seenKey.has(k)) transposedMatches.splice(i, 1);
                    else seenKey.add(k);
                }
            }
            const transposedChord = transposedMatches?.[0] ?? null;

            const corrOrig = originalChord ? correctChordSpelling(selectedNotes, originalChord.type, originalChord.root) : selectedNotes;
            const corrTransposed = transposedChord ? correctChordSpelling(adjusted, transposedChord.type, transposedChord.root) : adjusted;

            const reset = () => { setSelectedNotes([]); setShowTransposed(false); };

            const isActive = (notes, note, octave) => {
                const ns = `${note}${octave}`;
                if (notes.includes(ns)) return true;
                const enh = {'C#':['Db'],'Db':['C#'],'D#':['Eb'],'Eb':['D#'],'F#':['Gb'],'Gb':['F#'],'G#':['Ab'],'Ab':['G#'],'A#':['Bb'],'Bb':['A#'],'B':['Cb'],'Cb':['B'],'E#':['F'],'F':['E#'],'B#':['C'],'C':['B#']};
                return (enh[note] || []).some(eq => notes.includes(`${eq}${octave}`));
            };

            const Piano = ({ notes, title, interactive }) => (
                <div>
                    <div className="section-title">{title}</div>
                    <div className="piano">
                        <div className="octave">
                            {WHITE_KEYS.map((k,i) => (
                                <div key={i} className={`key white-key ${isActive(notes,k.note,k.octave)?'active':''}`}
                                     onClick={() => interactive && toggleNote(k.note, k.octave)}>{k.note}</div>
                            ))}
                            {BLACK_KEYS.map((k,i) => (
                                <div key={i} className={`key black-key ${isActive(notes,k.note,k.octave)?'active':''}`}
                                     data-position={k.position}
                                     onClick={() => interactive && toggleNote(k.note, k.octave)}>
                                    <span>{k.sharp}</span><span>{k.flat}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );

            const renderMatches = (matches, rawNotes, corrNotes) => matches?.map((match, idx) => {
                const mc = correctChordSpelling(rawNotes, match.type, match.root);
                const inv = getInversion(mc, match.root);
                // Sort notes low to high by pitch so the spelling order matches the inversion label
                const mcSorted = [...mc].sort((a, b) => {
                    const noteA = a.replace(/[0-9]/g,''), octA = parseInt(a.match(/[0-9]/g)[0]);
                    const noteB = b.replace(/[0-9]/g,''), octB = parseInt(b.match(/[0-9]/g)[0]);
                    return (octA * 12 + getChromaticIndex(noteA)) - (octB * 12 + getChromaticIndex(noteB));
                });
                const spelling = mcSorted.map(n => n.replace(/[0-9]/g,'')).join('-');
                return (
                    <div key={idx} style={{marginBottom: idx < matches.length-1 ? '0.5rem' : 0}}>
                        {match.root}{match.type}
                        {!match.complete && <span style={{fontSize:'1rem',marginLeft:'0.3rem',color:'#999'}}>(incomplete)</span>}
                        {inv && <span style={{fontSize:'1rem',marginLeft:'0.3rem',color:'#666'}}>({inv})</span>}
                        <div style={{fontSize:'1rem',color:'#999',marginTop:'0.3rem'}}>{spelling}</div>
                    </div>
                );
            });

            return (
                <div className="container">
                    <header>
                        <h1>The Piano Keys Chord Transposition Wizard</h1>
                        <p className="subtitle">
                            1. Click the keys on the piano to build your chord.<br/>
                            2. Choose a new root note from the dropdown.<br/>
                            3. Press Go to see the transposed chord on the lower keyboard.
                        </p>
                    </header>

                    <div className="section">
                        <Piano notes={corrOrig} title="Input Your Chord" interactive={true} />
                        {selectedNotes.length === 0 && <p className="instruction">Click the piano keys above to select notes</p>}
                        {originalChord && (
                            <div className="chord-info">
                                <div className="chord-name">{renderMatches(originalMatches, selectedNotes, corrOrig)}</div>
                                <button className="play-btn" onClick={() => playChord(corrOrig)}>ðŸ”Š Play Chord</button>
                            </div>
                        )}
                    </div>

                    <div className="section">
                        <div className="key-selector">
                            <div className="transpose-group">
                                <label>Build the same chord starting on:</label>
                                <div style={{display:'flex',gap:'1rem',alignItems:'center'}}>
                                    <select value={toRoot} onChange={e => { setToRoot(e.target.value); setShowTransposed(false); }}>
                                        <option value="">Select a note...</option>
                                        {DROPDOWN_NOTES.map(({ value, label }) => (
                                            <option key={value} value={value}>{label}</option>
                                        ))}
                                    </select>
                                    <button className="go-btn" onClick={handleGo} disabled={!toRoot || selectedNotes.length === 0}>Go</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    {showTransposed && selectedNotes.length > 0 && toRoot && (
                        <div className="section" ref={transposedRef}>
                            <Piano notes={adjusted} title="Transposed Result" interactive={false} />
                            {transposedChord && (
                                <div className="chord-info">
                                    <div className="chord-name">{renderMatches(transposedMatches, adjusted, corrTransposed)}</div>
                                    <div className="button-group">
                                        <button className="play-btn" onClick={() => playChord(rawTransposed)}>ðŸ”Š Play Transposed Chord</button>
                                        <button className="reset-btn" onClick={reset}>Clear &amp; Start Over</button>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    <footer>
                        <div className="copyright">Copyright Â© 2026 The Piano Keys. All rights reserved.</div>
                        <div><a href="https://www.thepianokeys.com/" target="_blank" rel="noopener noreferrer">ThePianoKeys.com</a></div>
                    </footer>
                </div>
            );
        }

        ReactDOM.render(<ChordTransposer />, document.getElementById('root'));
    </script>
</body>
</html>
